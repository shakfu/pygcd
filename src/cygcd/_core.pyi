"""Type stubs for cygcd._core - Cython extension module."""

from typing import Callable, Optional

# Time constants
DISPATCH_TIME_NOW: int
DISPATCH_TIME_FOREVER: int
NSEC_PER_SEC_PY: int
NSEC_PER_MSEC_PY: int
NSEC_PER_USEC_PY: int
USEC_PER_SEC_PY: int
MSEC_PER_SEC_PY: int

# Queue priority constants
QUEUE_PRIORITY_HIGH: int
QUEUE_PRIORITY_DEFAULT: int
QUEUE_PRIORITY_LOW: int
QUEUE_PRIORITY_BACKGROUND: int

# QOS class constants
QOS_CLASS_USER_INTERACTIVE: int
QOS_CLASS_USER_INITIATED: int
QOS_CLASS_DEFAULT: int
QOS_CLASS_UTILITY: int
QOS_CLASS_BACKGROUND: int
QOS_CLASS_UNSPECIFIED: int

# Process event flags
PROC_EXIT: int
PROC_FORK: int
PROC_EXEC: int
PROC_SIGNAL: int

# I/O type constants
IO_STREAM: int
IO_RANDOM: int
IO_STOP: int

__version__: str

class Queue:
    """Dispatch queue for task execution."""

    def __init__(
        self,
        label: Optional[str] = None,
        concurrent: bool = False,
        qos: int = 0,
        relative_priority: int = 0,
        target: Optional[Queue] = None,
        inactive: bool = False,
    ) -> None: ...
    @staticmethod
    def global_queue(priority: int = 0) -> Queue: ...
    @staticmethod
    def main_queue() -> Queue: ...
    def run_async(self, func: Callable[[], None]) -> None: ...
    def run_sync(self, func: Callable[[], None]) -> None: ...
    def barrier_async(self, func: Callable[[], None]) -> None: ...
    def barrier_sync(self, func: Callable[[], None]) -> None: ...
    def after(self, delay_seconds: float, func: Callable[[], None]) -> None: ...
    def suspend(self) -> None: ...
    def resume(self) -> None: ...
    def activate(self) -> None: ...
    def set_target_queue(self, queue: Queue) -> None: ...
    @property
    def label(self) -> Optional[str]: ...
    @property
    def is_inactive(self) -> bool: ...

class Group:
    """Dispatch group for tracking task completion."""

    def __init__(self) -> None: ...
    def run_async(self, queue: Queue, func: Callable[[], None]) -> None: ...
    def wait(self, timeout: float = -1) -> bool: ...
    def notify(self, queue: Queue, func: Callable[[], None]) -> None: ...
    def enter(self) -> None: ...
    def leave(self) -> None: ...

class Semaphore:
    """Counting semaphore for resource limiting."""

    def __init__(self, value: int) -> None: ...
    def wait(self, timeout: float = -1) -> bool: ...
    def signal(self) -> bool: ...

class Once:
    """Thread-safe one-time execution."""

    def __init__(self) -> None: ...
    def __call__(self, func: Callable[[], None]) -> None: ...

class Timer:
    """Dispatch source timer."""

    def __init__(
        self,
        interval: float,
        handler: Callable[[], None],
        queue: Optional[Queue] = None,
        start_delay: float = 0.0,
        leeway: float = 0.0,
        repeating: bool = True,
    ) -> None: ...
    def start(self) -> None: ...
    def cancel(self) -> None: ...
    def set_timer(
        self,
        interval: float,
        start_delay: float = 0.0,
        leeway: float = 0.0,
    ) -> None: ...
    @property
    def is_cancelled(self) -> bool: ...

class SignalSource:
    """Dispatch source for Unix signal handling."""

    def __init__(
        self,
        signum: int,
        handler: Callable[[], None],
        queue: Optional[Queue] = None,
    ) -> None: ...
    def start(self) -> None: ...
    def cancel(self) -> None: ...
    @property
    def signal(self) -> int: ...
    @property
    def count(self) -> int: ...
    @property
    def is_cancelled(self) -> bool: ...

class ReadSource:
    """Dispatch source for file descriptor read monitoring."""

    def __init__(
        self,
        fd: int,
        handler: Callable[[], None],
        queue: Optional[Queue] = None,
    ) -> None: ...
    def start(self) -> None: ...
    def cancel(self) -> None: ...
    @property
    def fd(self) -> int: ...
    @property
    def bytes_available(self) -> int: ...
    @property
    def is_cancelled(self) -> bool: ...

class WriteSource:
    """Dispatch source for file descriptor write monitoring."""

    def __init__(
        self,
        fd: int,
        handler: Callable[[], None],
        queue: Optional[Queue] = None,
    ) -> None: ...
    def start(self) -> None: ...
    def cancel(self) -> None: ...
    @property
    def fd(self) -> int: ...
    @property
    def buffer_space(self) -> int: ...
    @property
    def is_cancelled(self) -> bool: ...

class ProcessSource:
    """Dispatch source for process event monitoring."""

    def __init__(
        self,
        pid: int,
        handler: Callable[[], None],
        events: int = ...,
        queue: Optional[Queue] = None,
    ) -> None: ...
    def start(self) -> None: ...
    def cancel(self) -> None: ...
    @property
    def pid(self) -> int: ...
    @property
    def events_pending(self) -> int: ...
    @property
    def is_cancelled(self) -> bool: ...

class Data:
    """Immutable dispatch data buffer."""

    def __init__(self, data: Optional[bytes] = None) -> None: ...
    def concat(self, other: Data) -> Data: ...
    def subrange(self, offset: int, length: int) -> Data: ...
    @property
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    def __bytes__(self) -> bytes: ...

class Workloop:
    """Dispatch workloop for priority-inversion-avoiding execution."""

    def __init__(self, label: str, inactive: bool = False) -> None: ...
    def run_async(self, func: Callable[[], None]) -> None: ...
    def run_sync(self, func: Callable[[], None]) -> None: ...
    def activate(self) -> None: ...
    @property
    def is_inactive(self) -> bool: ...

class IOChannel:
    """High-performance async file I/O channel."""

    def __init__(
        self,
        fd: int,
        io_type: int = ...,
        queue: Optional[Queue] = None,
        cleanup_handler: Optional[Callable[[int], None]] = None,
    ) -> None: ...
    def read(
        self,
        length: int,
        handler: Callable[[bool, Optional[bytes], int], None],
        offset: int = 0,
        queue: Optional[Queue] = None,
    ) -> None: ...
    def write(
        self,
        data: bytes,
        handler: Callable[[bool, Optional[bytes], int], None],
        offset: int = 0,
        queue: Optional[Queue] = None,
    ) -> None: ...
    def close(self, stop: bool = False) -> None: ...
    def set_high_water(self, size: int) -> None: ...
    def set_low_water(self, size: int) -> None: ...
    def set_interval(self, interval_ns: int, strict: bool = False) -> None: ...
    def barrier(self, handler: Callable[[], None], queue: Optional[Queue] = None) -> None: ...
    @property
    def fd(self) -> int: ...

# Functions
def apply(
    iterations: int,
    func: Callable[[int], None],
    queue: Optional[Queue] = None,
) -> None: ...
def time_from_now(seconds: float) -> int: ...
def walltime(timestamp: float = 0, delta_seconds: float = 0) -> int: ...
def read_async(
    fd: int,
    length: int,
    callback: Callable[[bytes, int], None],
    queue: Optional[Queue] = None,
) -> None: ...
def write_async(
    fd: int,
    data: bytes,
    callback: Callable[[bytes, int], None],
    queue: Optional[Queue] = None,
) -> None: ...
